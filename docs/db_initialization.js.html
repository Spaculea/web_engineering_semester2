<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: db/initialization.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: db/initialization.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @fileoverview Dieses Skript importiert alte Klausuren und L√∂sungen in eine PostgreSQL-Datenbank.
 * Es stellt sicher, dass die Datenbank bereit ist, bevor die Importe gestartet werden.
 * Es liest PDF-Dateien aus den angegebenen Verzeichnissen, extrahiert relevante Informationen aus den Dateinamen
 * und f√ºgt die Daten in die entsprechenden Tabellen ein.
 * @author Sergiu Paculea
 */
/**
 * @namespace dbInitialization
 * @description Dieses Modul enth√§lt Funktionen zum Importieren von Klausuren und L√∂sungen in die Datenbank
 * und zum Warten auf die Datenbankverbindung.
 * Es verwendet die PostgreSQL-Bibliothek 'pg' und die Node.js-Dateisystem- und Pfadmodule.
 */
const fs = require('fs');
const path = require('path');
const { Pool } = require('pg');

// Lade Umgebungsvariablen
require('dotenv').config();

/**
 * Datenbankkonfiguration
 * @typedef {Object} DatabaseConfig - Konfiguration f√ºr die PostgreSQL-Datenbankverbindung
 * @property {string} user - Der Benutzername f√ºr die Datenbankverbindung
 * @property {string} host - Der Hostname der Datenbank
 * @property {string} database - Der Name der Datenbank
 * @property {string} password - Das Passwort f√ºr die Datenbankverbindung
 * @property {number} port - Der Port f√ºr die Datenbankverbindung
 */

/**
 * Gemeinsame Konfiguration f√ºr die PostgreSQL-Datenbankverbindung.
 * Diese Konfiguration wird f√ºr die Verbindung zur Datenbank verwendet, um Klausuren und L√∂sungen zu importieren.
 * @type {databaseConfig}
 */
const dbConfig = {
    user: process.env.DB_USER || 'postgres',
    host: process.env.DB_HOST || 'localhost',
    database: process.env.DB_NAME || 'dhbw_klausuren',
    password: process.env.DB_PASSWORD || 'sese20022003',
    port: parseInt(process.env.DB_PORT, 10) || 5400
};

/**
 * Maximale Anzahl an Versuchen, um eine Verbindung zur Datenbank herzustellen.
 * @constant {number}
 * @default 5
 * @memberOf dbInitialization
 */
const MAX_RETRIES = 5;

/**
 * Verz√∂gerung in Millisekunden, bevor ein erneuter Verbindungsversuch unternommen wird.
 * @constant {number}
 * @default 1000
 * @memberOf dbInitialization
 */
const RETRY_DELAY = 1000; // 1 Sekunde

// Verzeichnisse
const klausurenDirectory = './src/assets/Klausuren';
const loesungenDirectory = './src/assets/Loesungen';

/**
 * @async
 * @function waitForDatabase
 * @memberof dbInitialization
 * @description Funktion, die versucht, eine Verbindung zur Datenbank herzustellen.
 * Sie wird mehrmals wiederholt, bis die Datenbank bereit ist oder die maximale Anzahl an
 * Versuchen erreicht ist.
 * @param {number} retries - Anzahl der verbleibenden Versuche, die Verbindung herzustellen.
 * @returns {Promise&lt;boolean>} - Gibt true zur√ºck, wenn die Verbindung erfolgreich war, andernfalls false.
 */
async function waitForDatabase(retries = MAX_RETRIES) {
    const pool = new Pool(dbConfig);

    try {
        console.log('Versuch, Verbindung zur Datenbank herzustellen...');
        const client = await pool.connect();
        console.log('‚úÖ Datenbankverbindung erfolgreich');
        client.release();
        return true;
    } catch (error) {
        await pool.end().catch(() => { });

        if (retries &lt;= 0) {
            console.error('‚ùå Datenbankverbindung fehlgeschlagen nach mehreren Versuchen:', error);
            return false;
        }

        console.log(`‚è≥ Datenbank noch nicht bereit. Warte ${RETRY_DELAY / 1000} Sekunden... (${retries} Versuche √ºbrig)`);

        // Warten vor dem n√§chsten Versuch
        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));

        // Wiederhole mit einem Versuch weniger
        return waitForDatabase(retries - 1);
    }
}

/**
 * Klausur-Objekt Struktur
 * @typedef {Object} Klausur
 * @property {number} id - Die eindeutige ID der Klausur in der Datenbank.
 * @property {string} name - Der Name der Klausur.
 * @property {string} fach - Das Fach, zu dem die Klausur geh√∂rt.
 * @property {string} semester - Das Semester, in dem die Klausur geschrieben wurde.
 * @property {Buffer} klausur_pdf - Die PDF-Datei der Klausur als Buffer.
 * @property {Date} created_at - Das Erstellungsdatum der Klausur in der Datenbank.
 */

/**
 * @async
 * @function importAltklausuren
 * @memberof dbInitialization
 * @description Importiert alte Klausuren in die Datenbank.
 * Pr√ºft, ob das Verzeichnis existiert und ob bereits gen√ºgend Eintr√§ge in der Datenbank vorhanden sind.
 * Liest die PDF-Dateien aus dem Verzeichnis, extrahiert die relevanten Informationen aus den Dateinamen
 * und f√ºgt die Daten in die Tabelle "klausuren" ein. 
 * @returns {Promise&lt;void>} Es gibt keinen R√ºckgabewert, aber es gibt Konsolenausgaben f√ºr den Fortschritt und Fehler.
 */

async function importAltklausuren() {
    const pool = new Pool(dbConfig);

    try {
        // Check if database already has content
        const result = await pool.query('SELECT COUNT(*) FROM klausuren');
        const count = parseInt(result.rows[0].count);

        // Pr√ºfen ob Verzeichnis existiert
        if (!fs.existsSync(klausurenDirectory)) {
            console.error(`PDF-Verzeichnis existiert nicht: ${klausurenDirectory}`);
            return;
        }

        const files = fs.readdirSync(klausurenDirectory).filter(file => file.endsWith('.pdf'));

        // Check for existing PDF files
        if (files.length === 0) {
            console.log('Keine PDF-Dateien gefunden. Import wird √ºbersprungen.');
            return;
        }

        // Check if the database already has enough entries
        if (count >= files.length) {
            console.log(`Datenbank enth√§lt bereits ${count} Klausuren. Import wird √ºbersprungen.`);
            return;
        }

        console.log(`${files.length} PDF-Dateien zum Importieren gefunden`);

        for (const file of files) {
            try {
                // Extract information from filename
                const parts = path.basename(file, '.pdf').split('_');
                const fach = parts[0];
                const semester = parts[1].replace('Semester', '');
                const name = parts[2];

                // Read PDF file
                const pdfData = fs.readFileSync(path.join(klausurenDirectory, file));

                // Insert into database
                await pool.query(
                    'INSERT INTO klausuren (name, fach, semester, klausur_pdf) VALUES ($1, $2, $3, $4)',
                    [name, fach, semester, pdfData]
                );

                console.log(`Importiert: ${file}`);
            } catch (err) {
                console.error(`Fehler beim Importieren von ${file}:`, err);
            }
        }

        console.log('‚úÖ Import der Klausuren abgeschlossen');
    } catch (error) {
        console.error('Fehler beim Klausurenimport:', error);
    } finally {
        await pool.end().catch(err => console.error('Fehler beim Schlie√üen des Pools:', err));
    }
}

/**
 * L√∂sungs-Objekt Struktur
 * @typedef {Object} Loesung
 * @property {number} id - Eindeutige ID der L√∂sung
 * @property {number} klausur_id - Verweis auf die zugeh√∂rige Klausur
 * @property {Buffer} loesung_pdf - PDF-Datei als Bin√§rdaten
 * @property {Date} created_at - Erstellungsdatum
 */

/**
 * @async
 * @function importLoesungen
 * @memberof dbInitialization
 * @description Importiert alte L√∂sungen in die Datenbank.
 * @returns {Promise&lt;void>} Es gibt keinen R√ºckgabewert, aber es gibt Konsolenausgaben f√ºr den Fortschritt und Fehler.
 */
async function importLoesungen() {
    const pool = new Pool(dbConfig);

    try {
        // Check if database already has content
        const result = await pool.query('SELECT COUNT(*) FROM loesungen');
        const count = parseInt(result.rows[0].count);

        // Pr√ºfen ob Verzeichnis existiert
        if (!fs.existsSync(loesungenDirectory)) {
            console.error(`PDF-Verzeichnis existiert nicht: ${loesungenDirectory}`);
            return;
        }

        // Initialize the database if empty
        const files = fs.readdirSync(loesungenDirectory).filter(file => file.endsWith('.pdf'));

        console.log(`${files.length} L√∂sungs-PDFs zum Importieren gefunden`);

        if (files.length === 0) {
            console.log('Keine PDF-Dateien gefunden. Import wird √ºbersprungen.');
            return;
        }

        if (count >= files.length) {
            console.log(`Datenbank enth√§lt bereits ${count} L√∂sungen. Import wird √ºbersprungen.`);
            return;
        }

        for (const file of files) {
            try {
                // Extract information from filename
                const parts = path.basename(file, '.pdf').split('_');
                const fach = parts[0];
                const semester = parts[1].replace('Semester', '');
                const name = parts[2];

                // WICHTIG: Finde die zugeh√∂rige Klausur basierend auf Name und Fach
                const klausurResult = await pool.query(
                    'SELECT id FROM klausuren WHERE name = $1 AND fach = $2 AND semester = $3',
                    [name, fach, semester]
                );

                if (klausurResult.rows.length === 0) {
                    console.warn(`Keine passende Klausur gefunden f√ºr: ${file}`);
                    continue;
                }

                const klausur_id = klausurResult.rows[0].id;

                // Insert into database with the correct klausur_id
                // Read PDF file
                const pdfData = fs.readFileSync(path.join(loesungenDirectory, file));

                // Insert into database with the correct klausur_id and PDF data
                await pool.query(
                    'INSERT INTO loesungen (klausur_id, loesung_pdf) VALUES ($1, $2)',
                    [klausur_id, pdfData]
                );

                console.log(`Importiert: ${file} (verkn√ºpft mit Klausur-ID: ${klausur_id})`);
            } catch (err) {
                console.error(`Fehler beim Importieren von ${file}:`, err);
            }
        }

        console.log('‚úÖ Import der L√∂sungen abgeschlossen');
    } catch (error) {
        console.error('Fehler beim L√∂sungsimport:', error);
    } finally {
        await pool.end().catch(err => console.error('Fehler beim Schlie√üen der Datenbankverbindung:', err));
    }
}

/**
 * Hauptfunktion zur Ausf√ºhrung der Importe.
 * @async
 * @function runImports
 * @memberof dbInitialization
 * @description F√ºhrt die Importe f√ºr Klausuren und L√∂sungen aus. Die Function wartet zuerst darauf, dass die Datenbank bereit ist.
 * Die Importe werden nacheinander ausgef√ºhrt, und es gibt Konsolenausgaben f√ºr den Fortschritt.
 * @returns {Promise&lt;void>} Es gibt keinen R√ºckgabewert, aber es gibt Konsolenausgaben f√ºr den Fortschritt und Fehler.
 * @throws {Error} Gibt einen Fehler zur√ºck, wenn die Datenbank nicht bereit ist oder ein Import fehlschl√§gt.
 */
async function runImports() {
    console.log('üöÄ Starte Datenbankimporte...');

    // Warte zuerst auf die Datenbank
    const dbReady = await waitForDatabase();
    if (!dbReady) {
        console.error('‚ùå Datenbank ist nicht bereit. Abbruch des Imports.');
        return;
    }

    await importAltklausuren();
    await importLoesungen();
    console.log('‚úÖ Alle Importe abgeschlossen');
}

// Starte den Import
runImports().catch(error => {
    console.error('‚ùå Kritischer Fehler bei Datenbankimporte:', error);
    process.exit(1);
});</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="ClientSideFunctions.html">ClientSideFunctions</a></li><li><a href="ServerSideFunctions.html">ServerSideFunctions</a></li><li><a href="dbInitialization.html">dbInitialization</a></li></ul><h3><a href="global.html">Global</a></h3>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Fri Jul 25 2025 10:45:45 GMT+0200 (Mitteleurop√§ische Sommerzeit)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
